"use strict";(self.webpackChunkhandbook=self.webpackChunkhandbook||[]).push([[8057],{7315:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var i=t(5893),l=t(1151);const a={id:"queries",title:"Queries"},o=void 0,s={id:"specifications/aquadoggo/APIs/queries",title:"Queries",description:"- The GraphQL schema of a node changes depending on the schemas that are available on the node.",source:"@site/docs/specifications/aquadoggo/APIs/queries.md",sourceDirName:"specifications/aquadoggo/APIs",slug:"/specifications/aquadoggo/APIs/queries",permalink:"/specifications/aquadoggo/APIs/queries",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"queries",title:"Queries"},sidebar:"specifications",previous:{title:"Publishing",permalink:"/specifications/aquadoggo/APIs/publishing"},next:{title:"Blob HTTP service",permalink:"/specifications/aquadoggo/APIs/blob-http"}},r={},d=[{value:"<code>&lt;schema_id&gt;</code>",id:"schema_id",level:2},{value:"<code>all_&lt;schema_id&gt;</code>",id:"all_schema_id",level:2},{value:"types",id:"types",level:2},{value:"Scalars",id:"scalars",level:3},{value:"Responses",id:"responses",level:3},{value:"Filters",id:"filters",level:3},{value:"Ordering",id:"ordering",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",pre:"pre",ul:"ul",...(0,l.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The GraphQL schema of a node changes depending on the schemas that are available on the node."}),"\n",(0,i.jsxs)(n.li,{children:["A node inserts additional queryable fields into the root query type for every schema that can be queried.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"In addition, corresponding types for responses, pagination, ordering and filtering are generated according to the schemas' definitions."}),"\n",(0,i.jsx)(n.li,{children:"Together, these allow clients to request documents including their materialized views and metadata."}),"\n",(0,i.jsx)(n.li,{children:"Detailed descriptions of the generated types and queries follows below."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Therefore, client implementations SHOULD gracefully handle being connected to a node that doesn't process a schema they would like to interact with."}),"\n",(0,i.jsxs)(n.li,{children:["This specification defines a generic form for these dynamic GraphQL fields and types.","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The string ",(0,i.jsx)(n.code,{children:"<schema_id>"})," is used as a generic placeholder to be replaced by a concrete ",(0,i.jsx)(n.em,{children:"schema id"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"schema_id",children:(0,i.jsx)(n.code,{children:"<schema_id>"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Returns a single document that uses this schema","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implementations must have no side effects"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["The name of this field is equal to the ",(0,i.jsx)(n.em,{children:"schema id"})," of the schema it represents"]}),"\n",(0,i.jsxs)(n.li,{children:["Either the ",(0,i.jsx)(n.code,{children:"id"})," or ",(0,i.jsx)(n.code,{children:"viewId"})," field argument must be set","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"id"})," contains a document id, the response must contain the ",(0,i.jsx)(n.a,{href:"/specifications/aquadoggo/data-types/documents",children:(0,i.jsx)(n.em,{children:"latest document view"})})," for that document"]}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"viewId"})," contains a document view id, the response must contain this document view"]}),"\n",(0,i.jsx)(n.li,{children:"If both field arguments are given the view id is used"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:'Not every node holds all documents and especially not all document views (historical states of a document) in its database because of the decentralised nature of p2panda. in this case a "not found" error will be returned'}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type QueryRoot {\n  # ... other query root fields here ...\n\n  <schema_id>(\n    # id of the document to be queried\n    id: DocumentId\n\n    # specific document view id to be queried\n    viewId: DocumentViewId\n  ): <schema_id>\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"all_schema_id",children:(0,i.jsx)(n.code,{children:"all_<schema_id>"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Returns the ",(0,i.jsx)(n.a,{href:"/specifications/aquadoggo/data-types/documents",children:"latest document view"})," for many documents of a given schema","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Implementations must have no side effects"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"Deleted documents must not be included in the response unless they are explicitly included using a filter"}),"\n",(0,i.jsx)(n.li,{children:"Response is paginated, can be sorted and filtered"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"type QueryRoot {\n  # ... other query root fields here ...\n\n  # Get all <schema_id> documents with pagination, ordering and filtering.\n  all_<schema_id>(\n    # Filter the query based on field values\n    filter: <schema_id>Filter\n\n    # Filter the query based on meta field values\n    meta: MetaFilterInput\n\n    # Field by which items in the collection will be ordered\n    orderBy: <schema_id>OrderBy\n\n    # Direction which items in the collection will be ordered\n    orderDirection: OrderDirection\n\n    # Number of paginated items we want from this request\n    first: Int = 25\n\n    # The item we wish to start paginating from identified by a cursor\n    after: Cursor\n  ): <schema_id>Collection!\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"types",children:"types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A node's GraphQL schema contains both statically defined and dynamically created types."}),"\n",(0,i.jsx)(n.li,{children:"these types may relate to query arguments for handling filtering, ordering and pagination or types present on query responses."}),"\n",(0,i.jsxs)(n.li,{children:["dynamically created types always contain the ",(0,i.jsx)(n.code,{children:"schema_id"})," of the schema they are derived from in their name, whereas static types do not."]}),"\n",(0,i.jsxs)(n.li,{children:["for simple values scalar types are used:","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Document fields with the types ",(0,i.jsx)(n.code,{children:"Boolean"}),", ",(0,i.jsx)(n.code,{children:"Integer"}),", ",(0,i.jsx)(n.code,{children:"Float"})," and ",(0,i.jsx)(n.code,{children:"String"})," are represented with the corresponding GraphQL scalar types."]}),"\n",(0,i.jsxs)(n.li,{children:["Document fields with the relation types ",(0,i.jsx)(n.code,{children:"Relation"})," / ",(0,i.jsx)(n.code,{children:"RelationList"})," and ",(0,i.jsx)(n.code,{children:"PinnedRelation"})," / ",(0,i.jsx)(n.code,{children:"PinnedRelationList"})," use the type generated for that field's schema."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"the following is a list of all other generated and static types which can be found in a node's root GraphQL schema."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"scalars",children:"Scalars"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# cursor used in paginated queries.\nscalar Cursor\n\n# id of a p2panda document.\nscalar DocumentId\n\n# document view id of a p2panda document. Refers to a specific point in a documents history\n# and can be used to deterministically reconstruct it's state at that time.\nscalar DocumentViewId\n\n# signed bamboo entry, encoded as a hexadecimal string.\nscalar EncodedEntry\n\n# entry payload and p2panda operation, CBOR bytes encoded as a hexadecimal string.\nscalar EncodedOperation\n\n# hash of a signed bamboo entry.\nscalar EntryHash\n\n# log id of a bamboo entry.\nscalar LogId\n\n# public key that signed the entry.\nscalar PublicKey\n\n# sequence number of an entry.\nscalar SeqNum\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"responses",children:"Responses"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# response from a request for a single <schema_id> document\ntype <schema_id> {\n  # application fields of a `<schema_id>` document.\n  fields: <schema_id>Fields\n\n  # meta fields of a `<schema_id>` document.\n  meta: DocumentMeta\n}\n\n# application fields of a `<schema_id>` document.\ntype <schema_id>Fields {\n  # named fields containing the actual, materialized values of this document view. the form is defined by the regarding p2panda schema\n  <field_name>: <field_type>\n\n  # ... potentially more fields\n}\n\n# single page response returned when querying a collection of `<schema_id>` documents.\ntype <schema_id>Collection {\n  # total number of documents available in this paginated collection.\n  totalCount: Int!\n\n  # cursor for the next page\n  endCursor: String!\n\n  # boolean value denoting whether there is a next page available on this query.\n  hasNextPage: Boolean!\n\n  # field containing the actual document fields.\n  documents: [<schema_id>Item!]!\n}\n\n# single item in a paginated collection response\ntype <schema_id>Item {\n  # application fields of a `band` document.\n  fields: <schema_id>Fields\n\n  # meta fields of a `band` document.\n  meta: DocumentMeta\n\n  # the pagination `cursor` for this `<schema_id>` document.\n  cursor: String\n}\n\n# Meta fields of a document, contains id and authorship information.\ntype DocumentMeta {\n  # document id of this document.\n  documentId: DocumentId!\n\n  # document view id of this document.\n  viewId: DocumentViewId!\n\n  # public key of the author who first created this document.\n  owner: PublicKey!\n}\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"filters",children:"Filters"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"\n# A filter input type for boolean field values.\ninput BooleanFilter {\n  # Filter by equal to.\n  eq: Boolean\n\n  # Filter by not equal to.\n  notEq: Boolean\n}\n\n# A filter input type for integer field values.\ninput FloatFilter {\n  # Filter by values in set.\n  in: [Integer!]\n\n  # Filter by values not in set.\n  notIn: [Integer!]\n\n  # Filter by equal to.\n  eq: Integer\n\n  # Filter by not equal to.\n  notEq: Integer\n\n  # Filter by greater than or equal to.\n  gte: Integer\n\n  # Filter by greater than.\n  gt: Integer\n\n  # Filter by less than or equal to.\n  lte: Integer\n\n  # Filter by less than.\n  lt: Integer\n}\n\n# A filter input type for float field values.\ninput FloatFilter {\n  # Filter by values in set.\n  in: [Float!]\n\n  # Filter by values not in set.\n  notIn: [Float!]\n\n  # Filter by equal to.\n  eq: Float\n\n  # Filter by not equal to.\n  notEq: Float\n\n  # Filter by greater than or equal to.\n  gte: Float\n\n  # Filter by greater than.\n  gt: Float\n\n  # Filter by less than or equal to.\n  lte: Float\n\n  # Filter by less than.\n  lt: Float\n}\n\n# A filter input type for string field values.\ninput StringFilter {\n  # Filter by values in set.\n  in: [String!]\n\n  # Filter by values not in set.\n  notIn: [String!]\n\n  # Filter by equal to.\n  eq: String\n\n  # Filter by not equal to.\n  notEq: String\n\n  # Filter by greater than or equal to.\n  gte: String\n\n  # Filter by greater than.\n  gt: String\n\n  # Filter by less than or equal to.\n  lte: String\n\n  # Filter by less than.\n  lt: String\n\n  # Filter for items which contain given value.\n  contains: String\n\n  # Filter for items which don't contain given value.\n  notContains: String\n}\n\n\n# A filter input type for relation field values.\ninput RelationFilter {\n  # Filter by equal to.\n  eq: DocumentId\n\n  # Filter by not equal to.\n  notEq: DocumentId\n\n  # Filter by values in set.\n  in: [DocumentId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentId!]\n}\n\n# A filter input type for relation list field values.\ninput RelationListFilter {\n  # Filter by values in set.\n  in: [DocumentId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentId!]\n}\n\n# A filter input type for pinned relation field values.\ninput PinnedRelationFilter {\n  # Filter by equal to.\n  eq: DocumentViewId\n\n  # Filter by not equal to.\n  notEq: DocumentViewId\n\n  # Filter by values in set.\n  in: [DocumentViewId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentViewId!]\n}\n\n# A filter input type for pinned relation list field values.\ninput PinnedRelationListFilter {\n  # Filter by values in set.\n  in: [DocumentViewId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentViewId!]\n}\n\n# A filter input type for document id field on meta object.\ninput DocumentIdFilter {\n  # Filter by values in set.\n  in: [DocumentId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentId!]\n\n  # Filter by equal to.\n  eq: DocumentId\n\n  # Filter by not equal to.\n  notEq: DocumentId\n}\n\n# A filter input type for document view id field on meta object.\ninput DocumentViewIdFilter {\n  # Filter by values in set.\n  in: [DocumentViewId!]\n\n  # Filter by values not in set.\n  notIn: [DocumentViewId!]\n\n  # Filter by equal to.\n  eq: DocumentViewId\n\n  # Filter by not equal to.\n  notEq: DocumentViewId\n}\n\n# A filter input type for owner field on meta object.\ninput OwnerFilter {\n  # Filter by values in set.\n  in: [PublicKey!]\n\n  # Filter by values not in set.\n  notIn: [PublicKey!]\n\n  # Filter by equal to.\n  eq: PublicKey\n\n  # Filter by not equal to.\n  notEq: PublicKey\n}\n\n# Filter input containing all meta fields a collection of documents can be filtered by. Is\n# passed to the `meta` argument on a document collection query or list relation fields.\ninput MetaFilterInput {\n  # Document id filter.\n  documentId: DocumentIdFilter\n\n  # Document view id filter.\n  viewId: DocumentViewIdFilter\n\n  # Owner filter.\n  owner: OwnerFilter\n\n  # Edited filter.\n  edited: BooleanFilter\n\n  # Deleted filter.\n  deleted: BooleanFilter\n}\n\n# Filters for a documents' application fields\ninput <schema_id>Filter {\n  # field to filter by\n  <field_name>: BooleanFilter | IntegerFilter | FloatFilter | StringFilter | RelationFilter | RelationListFilter | PinnedRelationFilter | PinnedRelationListFilter\n\n  # ... potentially more fields\n}\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"ordering",children:"Ordering"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"\n# Possible ordering direction for collection queries.\nenum OrderDirection {\n  ASC\n  DESC\n}\n\nenum <schema_id>OrderBy {\n  DOCUMENT_ID\n  DOCUMENT_VIEW_ID\n  <field_name>\n  # ... potentially more fields\n}\n\n"})})]})}function u(e={}){const{wrapper:n}={...(0,l.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>o});var i=t(7294);const l={},a=i.createContext(l);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);